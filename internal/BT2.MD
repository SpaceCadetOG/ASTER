9-EMA Scalping Strategy with Volume Confirmation

This strategy is a short-term scalping approach that uses a 9-period Exponential Moving Average (EMA) as a primary signal trigger, reinforced by volume confirmation to validate breakouts. It is tailored for algorithmic backtesting on 5-minute cryptocurrency candles, incorporating additional filters (momentum indicators, session timing, volatility) and strict risk management. The goal is to catch quick momentum moves with high probability by confirming 9-EMA signals with strong volume and other criteria ￼ ￼.

Entry and Exit Rules

Entry Criteria (Long & Short)
	•	Long Entry: Trigger a buy when price demonstrates upward momentum relative to the 9 EMA and volume confirms the move. For example, a long signal occurs if the 5-minute candle closes above the 9-period EMA (indicating a bullish momentum shift) ￼, especially if it was below the EMA in prior bars (a breakout). This entry should only be taken if volume on the breakout candle is high (see Volume Confirmation below), and any additional filters (like RSI or time window) are satisfied. Optionally, a trend filter can be applied – e.g. ensure price is also above a longer-term EMA (such as a 50 EMA) or in an uptrend regime – so that longs align with the broader trend. ￼ ￼
	•	Short Entry: Trigger a sell/short when price shows downward momentum relative to the 9 EMA with volume confirmation. A short signal occurs if a candle closes below the 9 EMA after being above it (downward crossover or break of support) ￼. Again, require that the sell-off candle has unusually high volume supporting the move. As with longs, a trend filter can require price below a slower EMA or in a broader downtrend before shorting. All other filters (e.g. RSI condition) should indicate bearish momentum before entering short.

Both entry setups aim to catch momentum right as price crosses the 9 EMA with force. By waiting for a close beyond the EMA and confirming with volume, the strategy filters out many false signals (the 9 EMA alone can whipsaw in low-volatility conditions ￼). Entries are typically taken on the next bar’s open immediately after the signal bar closes beyond the EMA and meets conditions ￼, as per typical backtest execution.

Exit Criteria (Long & Short)
	•	Long Exit: Close the long position on any of the following conditions:
	•	EMA Exit: If price closes back below the 9 EMA after entry, indicating loss of upward momentum. The 9 EMA then acts as a trailing stop-guide for momentum; dropping below it is a cue to exit the long ￼.
	•	Profit Target/Stop: If a predefined take-profit level is hit (e.g. a prior resistance or a set Risk/Reward target) or if the stop-loss level is reached (see Risk Management). These can trigger an exit even if the 9 EMA hasn’t been crossed yet.
	•	Opposite Signal: If an outright short signal triggers (price crosses below 9 EMA with high volume in the opposite direction), one would exit the long (and could even flip short if allowed by strategy). Generally, only one trade direction is held at a time.
	•	Short Exit: Close the short position on analogous conditions:
	•	EMA Exit: If price closes back above the 9 EMA, indicating bearish momentum is fading and an upturn may be starting – exit the short.
	•	Profit/Stop: If a take-profit target for the short is hit (e.g. a prior support level or set profit objective) or the stop-loss is hit, exit the short.
	•	Opposite Signal: If a new long signal (price closing above 9 EMA on high volume) occurs, cover the short position to avoid getting caught on the wrong side of momentum.

In practice, many implementations use the 9 EMA as a trailing exit: for instance, riding a long trade until price closes below the 9 EMA, or using it intra-bar for a tighter trailing stop once in profit. Additionally, time-based exits (e.g. exit after X bars) can be used if a scalp trade fails to move as expected within a certain time window.

9-EMA as a Signal Trigger

The 9-period EMA is chosen for its responsiveness – it closely tracks short-term price swings, making it ideal for scalping on a 5-minute chart ￼. In this strategy, the 9 EMA serves as the line-in-the-sand for momentum:
	•	A candle closing above the 9 EMA signals bullish short-term momentum and triggers consideration of a long entry ￼ ￼. Conversely, a close below the 9 EMA signals bearish momentum and triggers a short entry. These simple crossover signals (price vs. EMA) form the core triggers for trades.
	•	Because the 9 EMA reacts quickly to price, it can generate frequent signals. To improve reliability, the raw EMA signal is confirmed with other factors before acting. The quick response of 9 EMA means it catches trend shifts early, but also can whipsaw; thus we only trade a 9-EMA crossover when additional evidence (volume, etc.) supports it ￼ ￼.
	•	Some variations use multiple EMAs (for example a 9 EMA crossing a 21 EMA as a trigger ￼), or require price above/below a longer average (like 50 or 200 EMA) to define the major trend. But the essence remains: the 9-EMA indicates immediate momentum direction. In our scalping logic, it’s the threshold for being long-biased or short-biased on each bar.

Using the 9 EMA as a trigger: When price moves above the 9 EMA line, it generates a buy signal; when price moves below, it generates a sell signal ￼. Traders monitor these crossovers and often demand the break above/below the EMA to be “significant” – for example, a strong close away from the EMA rather than just a tiny move, to avoid false breaks. In code-like terms, one might check if close_price[t] > EMA9[t] and close_price[t-1] <= EMA9[t-1] for a bullish crossover (and vice versa for bearish). This ensures we only trade on a fresh cross or a clean pullback touch of the EMA, not on every bar that happens to be above/below it.

Volume Confirmation

Volume is a critical confirmation in this strategy – it helps distinguish true momentum breakouts from feeble moves. The strategy looks for surges in volume concurrent with the price crossing the 9 EMA, as a sign that participation is high and the move is more likely to follow through. Key volume confirmation rules/techniques include:
	•	Above-Average Volume Breakout: Require that the entry signal candle’s volume is substantially higher than recent average. A common filter is to check that volume on the breakout bar is, for example, at least 1.5× the average volume of the past N bars (N could be 20, 50, etc.) ￼. Historical studies show breakouts with ~50% or more above-average volume are more likely to succeed ￼. This rule ensures we only enter when there is unusual trading activity backing the price move (indicative of institutional or significant trader involvement). If volume is flat or below average during a price crossover, the strategy will skip the trade due to lack of confirmation.
	•	Volume Spike / Surge: Instead of a moving average, one can simply define a volume spike threshold – e.g., the highest volume in the last 10 candles or a sudden jump relative to recent bars. If the signal bar’s volume is in, say, the top 5% of the last week’s 5-min bars, that’s a strong confirmation. The idea is similar: a spike in volume at the moment of price breakout greatly increases confidence in the signal. “Volume fuels breakouts – without it, even perfect chart patterns fail,” as one trading guide notes ￼. So the strategy watches for a volume surge concurrent with the EMA crossover.
	•	On-Balance Volume (OBV) Trend: As an alternative or supplement, volume confirmation can come from volume trend indicators like OBV. OBV accumulates volume based on price direction (adding volume on up-closes, subtracting on down-closes), revealing whether volume flow is positive or negative over time ￼. For a long trade, the strategy might require that OBV is rising or near recent highs, indicating buyers are cumulatively in control. Similarly, a new short signal might need OBV trending down. In practice, one might check that OBV is above its own short-term moving average or making higher highs alongside price to confirm a bullish breakout ￼. A flattening or falling OBV while price breaks above 9 EMA would warn that the volume behind the move isn’t supportive.
	•	Volume and Price Pattern Confluence: Beyond raw volume numbers, some strategies incorporate pattern-based volume confirmation. For example, in a bull flag continuation setup, the “flagpole” should be a sharp price rise on high volume, the consolidation on lighter volume, and then the breakout from the flag on another volume uptick ￼. In our context, a long trade is especially attractive if it comes after a low-volume consolidation and then a high-volume breakout above the 9 EMA. Increasing volume on successive candles in the direction of the trade is a good sign (e.g., several bars in a row making higher volume as price rallies through the EMA) ￼.

By enforcing a volume condition (e.g. Volume[t] > 1.5 × SMA(Volume,20), or Volume[t] is highest in last 50 bars, etc.), the backtester ensures only high-quality signals are taken. In summary, price must cross the 9 EMA and do so on convincingly high volume for a trade to be entered. This two-factor trigger greatly improves reliability: “Increasing trading volume during price crossovers above the 9 EMA strengthens the signal’s reliability.” ￼

Additional Filters and Conditions

To further refine the strategy and avoid low-probability trades, several additional filters can be applied:
	•	Momentum Filter (RSI or Similar): Incorporating a momentum oscillator like RSI can filter out entries that occur when price is overextended. For example, require the RSI (e.g. 14-period or even a fast 9-period RSI) to be in an appropriate range before trading. A common rule: only go long if RSI is above a certain threshold (e.g. > 50) and not yet overbought (> 70), indicating bullish momentum without being too stretched; for shorts, require RSI < 50 and not deeply oversold < 30 ￼. RSI can also be used to confirm signals: a long setup is more convincing if RSI has just climbed out of an oversold region or is showing a bullish divergence, meaning momentum is improving. In one example, a sell signal (short entry) was confirmed by RSI “pulling down from overbought” at the same time price broke below the 9 EMA ￼ – this kind of dual confirmation improves win rate. Overall, the RSI filter ensures we trade with momentum and avoid counter-trend EMA signals (e.g., skip a “price above 9 EMA” signal if RSI is bearish or extremely overbought, which might predict a failure).
	•	Time-of-Day / Session Filter: Even though crypto trades 24/7, volume and volatility vary by time of day. The strategy can restrict trading to periods of higher liquidity and avoid dead zones. For instance, studies show that crypto trading activity and volatility peak during the overlap of major market hours (e.g. roughly 16:00-17:00 UTC, when both European and U.S. markets are active) ￼, while late-night/early-morning UTC has the weakest volume and wider spreads ￼. A filter might enable trading only between certain hours – for example, avoid low-volume overnight sessions or weekends when erratic moves or slippage are more likely ￼. Focusing on active sessions (when volume confirmation is more meaningful) can improve performance. In backtests, one might simply ignore signals that occur during designated low-volume hours. (For example, only trade between 08:00 and 20:00 UTC, and skip others.)
	•	Volatility/Range Filter: The strategy can require a certain minimum volatility regime to be in effect, to avoid choppy sideways markets where the 9 EMA crossover signals are unreliable. One approach is using the Average True Range (ATR) or recent high-low range: if the ATR on the 5m chart is below a threshold (too low), the market may be ranging tightly and we risk whipsaws – so we hold off trading until volatility picks up. Conversely, if volatility is extremely high (huge ATR spikes), one might also pause trading to avoid unpredictable swings or widen stops accordingly. A practical rule: do not enter trades when the 9 EMA signal flips back-and-forth within a narrow price range, which is a sign of consolidation ￼. Instead, wait for a range breakout. Some strategies explicitly check that the price’s recent range or Bollinger Band width exceeds a minimum value before allowing a trade. By filtering out low-volatility periods, we ensure the 9-EMA signals occur in environments where follow-through is more likely.
	•	Trend or Higher-Timeframe Filter: As noted, a second moving average (like a 50-period EMA on the same 5m chart, or using a higher timeframe trend) can act as a filter. Only take longs if the higher timeframe trend is up, and shorts if it’s down. For example, if using a 50 EMA on the 5m chart as a proxy for the broader trend: Long trades only if price is above the 50 EMA (uptrend), short trades only if below the 50 EMA. This prevents counter-trend scalps. Another approach is to check a higher timeframe (say 1-hour chart) to ensure alignment – though this adds complexity to a 5m strategy. Many scalpers keep it simple with just a local trend filter (like a 20 EMA or 50 EMA) to stay on the right side of momentum ￼.
	•	Avoid Major News/Events: While hard to quantify, some backtesters will simply avoid trading during known scheduled major news events (if any affect crypto) or around times of major economic releases (for forex this is common; for crypto, maybe around big announcements). In a strategy logic, this could be implemented as a time filter or manually removing those intervals from backtest data. The rationale is to avoid unpredictability that technical signals can’t account for.

Each of these filters adds a layer of confirmation or risk control. In code or pseudocode, these would appear as additional if conditions that must be true along with the basic 9 EMA crossover signal before an entry is allowed. Using multiple confirmations significantly improves accuracy of 9-EMA signals ￼, at the cost of fewer trades.

Example Pseudocode Logic

Below is a high-level pseudocode outline combining the above rules. This logic would be executed on each new 5-minute bar in a backtesting engine:
	1.	Compute Indicators per Bar: For each bar (at close):
	•	Calculate ema9 = EMA(close, period=9) for the current bar.
	•	Compute volume benchmark, e.g. avg_vol20 = SMA(volume, period=20) for recent volume.
	•	Compute rsi = RSI(close, period=14) (or any momentum indicator if used).
	•	(If using ATR or volatility filter, calculate atr = ATR(14) or recent range as needed.)
	•	(If using trend filter, compute ema50 or check higher timeframe trend status.)
	2.	No Position – Look to Enter: If currently not in any position, evaluate entry criteria:
	•	Long Setup: If current close > ema9 and previous close ≤ ema9 (price just crossed above 9 EMA) ￼, then check confirmations:
	•	Volume condition: current bar’s volume > 1.5 * avg_vol20 (for example) or volume is at a X-bar high (indicating a spike) ￼.
	•	Momentum condition: e.g. rsi > 50 and not in overbought zone (or RSI rising from a low).
	•	Time/volatility condition: ensure we are in allowed trading hours and ATR or range is sufficient (no entry if the market is too quiet or the signal bar is too small).
	•	If all conditions are true, enter a Long position on the next bar’s open price ￼. Set stop-loss and take-profit levels (see Risk Management below).
	•	Short Setup: If current close < ema9 and previous close ≥ ema9 (price just crossed below 9 EMA), then confirm:
	•	Volume: bar volume is well above average (similar threshold as long) ￼.
	•	Momentum: e.g. rsi < 50 and not extremely oversold, or RSI falling.
	•	Time/volatility: within allowed session, adequate ATR, etc., similar to long.
	•	If all confirm, enter a Short position at next bar open. Set stop-loss/take-profit accordingly.
(Note: Instead of a simple cross, one could also allow entries on touches of the 9 EMA in trend. For instance, if an uptrend is identified, a long entry might trigger when price pulls back and touches the rising 9 EMA then bounces, even without a full cross below it. This was suggested by some traders to get “perfect” pullback entries ￼. Pseudocode would then adjust to detect a touch of EMA support in an uptrend as a buy signal.)
	3.	Manage Open Position (Long): If a long position is currently open, check exit conditions each bar:
	•	If price closed below the 9 EMA (loss of momentum) or any bearish signal arises (e.g. a high-volume close below 9 EMA indicating a potential short signal), then exit the long position at market (e.g. close of this bar or next open) ￼.
	•	Additionally, if stop-loss level is breached (intrabar low <= stop) or take-profit reached (intrabar high >= target), then exit. In a backtest, if the low of the current bar went below the stop price, we record an exit at that stop price or next bar’s open ￼ ￼. Likewise for a target being hit.
	•	Optionally, update a trailing stop: e.g., for a long, if a new high is made, raise the stop-loss to lock in profit (such as trailing behind the 9 EMA or by a fixed amount). This can be done by tracking the highest favorable price and moving the stop up accordingly.
	4.	Manage Open Position (Short): If a short position is open:
	•	If price closed back above the 9 EMA or a bullish reversal signal triggers, exit the short position.
	•	If the bar’s high hits the stop-loss level or low hits the take-profit, exit the short (recording the exit price accordingly in backtest).
	•	Update trailing stop for short (lowering the stop as price moves in favor, e.g. trailing above new lower highs).
	5.	Risk and Position Limits: Before entering any new position, ensure risk limits are respected:
	•	For example, do not enter a new trade if one is already open for that symbol (to avoid doubling up). Many backtesters restrict to at most one position per symbol or per direction at a time ￼.
	•	Ensure the position size calculation corresponds to the allowed capital at risk (discussed below). If taking multiple concurrent trades on different assets, ensure total exposure is within limits.

This pseudocode represents a structured decision process each bar. In a backtesting engine (such as a Go-based engine or Python script), it would loop through each time step, evaluate these conditions, and simulate orders. All signals are based on bar closes – no intra-bar decision-making (which aligns with typical backtest assumptions to avoid lookahead bias). The actual trade entry is executed at the next bar’s open price after a signal is identified ￼, and stops/exits are similarly handled on bar data boundaries.

Risk Management Considerations

Risk management is crucial in a scalping strategy to ensure no single trade (or series of trades) can cause catastrophic loss. Key risk management rules for this 9-EMA scalping strategy include:
	•	Position Sizing: Use a fixed fraction of capital per trade to limit risk. A common guideline is to risk no more than 1–2% of account equity on any single trade ￼ ￼. In practice, this means position size is determined based on the distance to the stop-loss and the 1-2% risk threshold. For example, if the account is $10,000 and risking 1% ($100) on a trade, and the stop-loss is 0.5% below entry, one could take a $20,000 position (which is $100/0.005) – margin allowing. The strategy should dynamically calculate position_size = risk_amount / (entry_price * stop_distance_percent) for each trade. By keeping risk per trade low, we survive losing streaks. Position sizing can also be fixed quantity for simplicity in backtests, but the 1-2% risk rule is the principle.
	•	Stop-Loss Placement: Every trade is protected by a stop-loss order from the outset. For longs, the stop is typically placed just below a recent support level or technical level. In this strategy, a logical stop is often slightly below the 9 EMA or below the last swing low formed when price crossed the EMA. One approach: place stop just under the 19 EMA or another slightly longer average as a buffer ￼, ensuring the stop is tight but not so tight as to get hit by normal noise. In some cases, a fixed percentage stop (e.g. 0.5% or 1% below entry price for a 5m scalp) can be used. For shorts, the stop goes just above a recent swing high or above a reference like the 19 EMA. The engine code will check each bar if the low (for long) fell below the stop price (or high for short above stop) and, if so, exit at next available price ￼ ￼. This ensures losses are cut quickly. Example: If long at $100 with a stop at $98 (2% risk), and price goes down, as soon as a 5-min bar touches $98 or below, the trade will exit, locking the loss around 2% (in backtest, often at next bar open near that price).
	•	Take-Profit Targets: Define clear profit-taking rules. One straightforward method is using a Risk-Reward multiple – e.g., target at least 2:1 reward-to-risk. If risking 1% downside, aim for 2% or more upside. In our example above (entry $100, stop $98 = $2 risk), the take-profit could be around $104 (which is $4 gain, 1:2 R:R). The strategy can set a limit order or simply monitor and exit when that level is hit. Another method is to target a recent high/low or technical level: for a long, perhaps the recent swing high or a resistance level becomes the profit target ￼. Scalpers often prefer to secure profits relatively quickly, so they might use a fixed target like +0.5% or +1% on the position if that yields a good R:R with their stop. The chosen take-profit approach should align with how often winners vs losers occur – many will use at least 1:1 or greater to ensure profitability. It’s also common to take partial profits at certain points and move the stop to breakeven on the remainder. In code/backtest, the logic will check each bar if the high (for long) exceeded the profit target and trigger an exit if so (or next bar open) ￼ ￼.
	•	Trailing Stop and Exit Management: Instead of (or in addition to) a fixed take-profit, the strategy can employ trailing stops to let winners run. For example, once a trade is +1% in profit, the stop-loss might be moved to breakeven. As the price continues in favor, the stop can trail just below the 9 EMA or a certain percentage from the peak price. The code tracks the max favorable price reached (p.maxF in the provided engine code) and compares current price to a trailing threshold ￼ ￼. For instance, one might trail at 0.5% below the highest price attained for a long; if current bar’s low falls below that trailing stop level, exit at next open ￼ ￼. Trailing stops help capture larger trends if they develop, while still protecting profits. The trade-off is sometimes getting stopped out by a pullback before a bigger move; each trader can adjust the trail tightness. In our logic, we might implement: if price exceeds entry by X, start trailing the stop at Y below the max price, etc. This can be done each bar as shown in the engine (updating p.maxF and checking trailHit) ￼ ￼.
	•	Max Concurrent Positions: Control how many trades can be open at once. In a scalping strategy on a single asset, it’s common to allow only one position at a time (you wait to exit before possibly reversing). If trading multiple pairs, one might limit the total open positions to avoid overloading. For example, configuration might set MaxOpenPositions = 3 (or 1 per symbol) ￼. Our backtest engine check if len(open) < MaxOpenPositions before opening a new trade ￼, meaning if we’ve hit the limit, additional signals are ignored until a position is closed. This prevents risking too much at once or doubling up on highly correlated assets.
	•	Avoiding Overtrading: Scalping can tempt frequent trades. The strategy should include rules to avoid entering trades too frequently or right after a loss without a valid signal. For instance, if two or three trades in a row were stopped out, a trader might pause trading for a while or become more selective (though this is more discretionary). In code, one might limit one trade per bar or enforce that a new trade signal is only taken if the previous bar wasn’t also a signal (to avoid multiple triggers in rapid succession). Ensuring high-quality signals (volume-backed, etc.) as we do is part of avoiding overtrading.
	•	Leverage and Fees: If leverage is used (common in crypto futures for scalping), keep it moderate to control risk, and account for trading fees and funding rates. In backtest assumptions, one might include a small fee deduction per trade (e.g. 0.04% per trade side as taker fee) which is considered in net results. The strategy should not rely on unrealistic zero-cost trading or infinite liquidity; slippage settings (maybe a few basis points) can be added for realism. Our engine config had fields for slippage and fees which can be used to simulate this ￼.

In summary, protective stops, sizing, and disciplined profit-taking are integral. A trader following this strategy would predefine their stop and target on entry and stick to them, adjusting stops in a favorable move but never widening a stop if the trade goes wrong. By risking a small fixed percent of equity each trade and aiming for at least as much reward, the strategy ensures that no string of losses will wipe out the account and that winners outweigh losers over time ￼ ￼.

Assumptions for Backtesting

When implementing this strategy in a backtest (especially in a bar-based engine like a Go backtester on 5m data), we make several assumptions and simplifications:
	•	Bar Close Signals: All decisions are made at the close of each 5-minute candle. The strategy does not peek into intra-bar movement. This means a signal like “price crossed above 9 EMA” is only recognized once the 5m bar has closed with price above the EMA. We assume we cannot act in the middle of a candle on partial information. In the code, this is seen where we iterate bar by bar and make decisions at the bar close, then execute on the next bar ￼. This avoids look-ahead bias and mimics a realistic scenario where you wait for confirmation at the candle close.
	•	Next-Bar Execution: Entries and exits are executed at the next bar’s open (or close of the current bar, equivalently, but typically next open for clarity in backtests). For example, if a long signal is confirmed at the close of the 12:00–12:05 bar, the buy is placed at the open of the 12:05–12:10 bar at whatever that opening price is ￼. This is a common backtesting approach to ensure the signal was known before acting. It also implicitly includes any gap that might occur between bar close and next open (though on 5m crypto bars, gaps are negligible since trading is continuous).
	•	Stop/Target Handling: Because we are using discrete 5m data, the exact execution of stops and targets inside a bar requires assumptions. Typically:
	•	If during a given 5m bar after entry the low goes below the stop price (for a long), we assume the stop-loss is triggered. In backtest, one might exit at the stop price or the bar’s close or next open. A safer assumption is exit at the next bar’s open after the stop is hit, to avoid cherry-picking an intrabar price (the engine example exits at next.O on a stop hit ￼). This can slightly worsen outcomes compared to ideal stops, but is more realistic without tick data.
	•	Similarly, if the high goes above the take-profit level (for a long), we assume the target was hit and exit at next bar open or target price. Some backtest engines will approximate that the exit happened at the precise stop/limit price if it was between the bar’s open and close. Others choose next open for consistency. The main point is we assume we can get out at or near our stop/limit if the market touched it.
	•	No partial execution is considered – either the stop or target (or manual exit) triggers a full exit. If both stop and target were breached in the same bar (it can happen in fast moves), the strategy needs a rule (often assume the stop hits first if high and low both passed their thresholds in one bar, depending on order of evaluation). Many backtesters simulate that if low < stop < high < target in the same bar, the stop was hit first; if high > target > low > stop, then target hit first, etc., based on ordering. Without intrabar data, these are approximations.
	•	No Lookahead/Data Snooping: The strategy uses only information up to the current bar to make decisions – e.g., the moving averages, RSI, volume, etc. are all computed with historical data up to the last closed bar. There is no peeking into future bars. This seems obvious, but it’s worth stating since in code one must be careful not to accidentally use future data. The backtest engine’s design (e.g. the loop that goes through bars sequentially) enforces this ￼.
	•	Bar Alignment and Latency: We assume that our orders (entries and exits) are executed instantaneously at the bar boundaries (the next open). There’s no delay in submitting the order and getting filled. In reality, a slight delay or slippage might occur, but in backtest we idealize it or include a fixed slippage in the config (the provided engine had a SlippageBps parameter which could simulate a small adverse fill) ￼. We also assume sufficient liquidity that our trade doesn’t impact price (which for small retail size in crypto is reasonable, but if testing with huge size it might not be).
	•	5-Minute Resolution Only: We assume the strategy does not require any data finer than the 5-minute candles. All indicators (EMA, RSI, OBV, etc.) are computed on 5m bars, and decisions are only at that interval. No intra-bar price action (like tick or 1-minute detail) is used. This means certain rapid patterns or wicks might be “hidden” inside the 5m bar, but the strategy will not react until the bar closes. This is a conscious choice to keep the backtest simple and robust.
	•	Data Quality and Duration: The backtest typically runs on historical data for the chosen crypto (or multiple cryptos) over a significant period to evaluate performance. It’s assumed the historical 5m data is accurate and includes volume for each bar. We also assume the market conditions in backtest (volatility, volume regimes) resemble what we might face in forward testing – though regime changes can happen. It’s wise to test over various market conditions (bearish, bullish, sideways periods).
	•	Transaction Costs: As mentioned, we may incorporate a model for fees/slippage, but often backtests assume a small fee per trade. For example, each trade might be charged 0.04% (Binance taker fee ~4 bps) on entry and exit. Over many scalp trades, fees can eat profits, so including them gives a more realistic result. The pseudocode doesn’t explicitly show this, but the engine deducts fees on each trade (e.g. eq -= pfee on entry, and PnL minus fee on exit) ￼ ￼.
	•	Max Positions/Capital: If multiple assets are traded, the backtest should have logic to not exceed available capital (though if using percent risk, it naturally stays in bounds). The provided engine config had MaxConcurrent and uses cfg.PositionNotional for position sizing ￼. In our single-asset scenario, we mostly just ensure one trade at a time. The capital is assumed sufficient for that one position with margin if needed.

By adhering to these assumptions, the backtest remains conservative and credible. Bar-based backtesting might miss some opportunities where intra-bar signals could allow earlier entry or tighter stops, but it avoids giving the strategy unfair advantages that wouldn’t exist in real trading. Always, after backtesting, it’s recommended to do forward testing (paper trading) to validate that these assumptions hold up in live conditions ￼.

Sources:
	•	Quantified Strategies – “9 EMA Trading Strategy: Rules, Setup, Performance and Backtest.” (overview of 9 EMA signals and confirmations) ￼ ￼
	•	NetPicks Trading – “Boost Your Trading with the 9 EMA.” (on combining 9 EMA with volume, RSI, and risk management rules) ￼ ￼
	•	LuxAlgo Blog – “How Volume Confirms Breakouts in Trading.” (volume >= 150% of average as a breakout filter) ￼
	•	Reddit r/Daytrading – user post on 9 EMA scalping (1m chart example with 9 & 19 EMA, entry/exit rules and R:R) ￼ ￼
	•	CoinBureau – “Crypto Trading Hours: Best Times for Successful Trades.” (on volume peaks during certain hours vs low-volume times) ￼ ￼
	•	Backtest Engine Code (Go) – illustrates bar-by-bar decision logic, next-bar execution, and trailing stop handling ￼ ￼ ￼ ￼. (Provided by user for context)